<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Fuchsia Mod Development Reference: Session Interface Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Fuchsia Mod Development Reference
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Groups</span></a></li>
      <li class="current"><a href="annotated.html"><span>Interfaces</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Interface&#160;List</span></a></li>
      <li><a href="classes.html"><span>Interface&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Interface&#160;members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('interface_session.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Groups</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="interface_session-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Session Interface Reference<div class="ingroups"><a class="el" href="group__scenic.html">Scenic</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0d4b5c8ce83307474cac161a577df2ae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_session.html#a0d4b5c8ce83307474cac161a577df2ae">Enqueue</a> (array&lt; <a class="el" href="union_op.html">Op</a> &gt; op)</td></tr>
<tr class="separator:a0d4b5c8ce83307474cac161a577df2ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03362ea291f6aef33068b8371d571a2f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_session.html#a03362ea291f6aef33068b8371d571a2f">Present</a> (uint64 presentation_time, array&lt; handle&lt; event &gt;&gt; acquire_fences, array&lt; handle&lt; event &gt;&gt; release_fences)</td></tr>
<tr class="separator:a03362ea291f6aef33068b8371d571a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0bf458bd5ecf9658503df1f06e9c240"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_session.html#ae0bf458bd5ecf9658503df1f06e9c240">HitTest</a> (uint32 node_id, <a class="el" href="structvec3.html">vec3</a> ray_origin, <a class="el" href="structvec3.html">vec3</a> ray_direction)</td></tr>
<tr class="separator:ae0bf458bd5ecf9658503df1f06e9c240"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock">
<p>Definition at line <a class="el" href="session_8fidl_source.html#l00016">16</a> of file <a class="el" href="session_8fidl_source.html">session.fidl</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a0d4b5c8ce83307474cac161a577df2ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Session::Enqueue </td>
          <td>(</td>
          <td class="paramtype">array&lt; <a class="el" href="union_op.html">Op</a> &gt;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enqueue a list of operations, which will not take effect until <a class="el" href="interface_session.html#a03362ea291f6aef33068b8371d571a2f">Present()</a> is called. It is allowable to call <a class="el" href="interface_session.html#a0d4b5c8ce83307474cac161a577df2ae">Enqueue()</a> several times before calling <a class="el" href="interface_session.html#a03362ea291f6aef33068b8371d571a2f">Present()</a>; the effect is the same as if all operations had been concatenated into a single <a class="el" href="interface_session.html#a0d4b5c8ce83307474cac161a577df2ae">Enqueue()</a> call. </p>

</div>
</div>
<a class="anchor" id="ae0bf458bd5ecf9658503df1f06e9c240"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Session::HitTest </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>node_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvec3.html">vec3</a>&#160;</td>
          <td class="paramname"><em>ray_origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvec3.html">vec3</a>&#160;</td>
          <td class="paramname"><em>ray_direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a hit test along the specified ray.</p>
<p>Returns a list of intersections of tagged nodes between the ray and the geometry of the subtree of nodes at |node_id|. Results are sorted by increasing distance from the ray's origin. Nodes which are hit at the same distance are sorted by the sequence they would appear in a post-order tree traversal of the scene. Equivalently, the results are ordered by decreasing hit specificity.</p>
<p>The session must associate a tag with any nodes it would like to observe in the result set. Untagged nodes are still considered in hit tests and may cause hits to be reported for containing nodes which are tagged.</p>
<p>The hit test only considers the currently presented content at the time of the request. This means that content pending presentation may not be considered for hit testing until the scene manager begins preparing a frame which includes it.</p>
<p>|ray_origin| is a point in the node's local coordinate system from which the hit test ray originates.</p>
<p>|ray_direction| is a vector in the node's local coordinate system which expresses how the ray propagates from the origin. It must be non-zero (otherwise nothing will be hit) but it does not need to be normalized.</p>
<p>Returns a null hit array if |node_id| is unknown or not a node. </p>

</div>
</div>
<a class="anchor" id="a03362ea291f6aef33068b8371d571a2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Session::Present </td>
          <td>(</td>
          <td class="paramtype">uint64&#160;</td>
          <td class="paramname"><em>presentation_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; handle&lt; event &gt;&gt;&#160;</td>
          <td class="paramname"><em>acquire_fences</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; handle&lt; event &gt;&gt;&#160;</td>
          <td class="paramname"><em>release_fences</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Present all previously enqueued operations. In order to pipeline the preparation of the resources required to render the scene, two lists of fences (implemented as events) are passed.</p>
<p>SCHEDULING PRESENTATION</p>
<p>|presentation_time| specifies the time on or after which the client would like the enqueued operations should take visible effect (light up pixels on the screen), expressed in nanoseconds in the |CLOCK_MONOTONIC| timebase. Desired presentation times must be monotonically non-decreasing.</p>
<p>Using a desired presentation time in the present or past (such as 0) schedules enqueued operations to take visible effect as soon as possible (during the next frame to be prepared).</p>
<p>Using a desired presentation time in the future schedules the enqueued operations to take visible effect as closely as possible to or after the stated time (but no earlier).</p>
<p>Each rendered frame has a target presentation time. Before rendering a frame, the scene manager applies all enqueued operations associated with all prior calls to |Present()| whose desired presentation time is on or before the frame's target presentation time.</p>
<p>The |Present()| method does not return until the scene manager begins preparing the first frame which includes its presented content. Upon return, the |PresentationInfo| provides timing information for the frame which includes the presented content.</p>
<p>To present new content on each successive frame, wait for |Present()| to return before calling |Present()| again with content for the next frame.</p>
<p>It is also possible to enqueue and present successive frames of content all at once with increasing desired presentation times, incrementing by |PresentationInfo.presentation_interval| for each one.</p>
<p>Animation updates are also coordinated in terms of presentation time.</p>
<p>TODO(jeffbrown): Defining presentation time in terms of |CLOCK_MONOTONIC| simplifies synchronization across subsystems but it might be too simple. We should consider using a synthetic timebase and describing its relation to other clocks separately. That would make it possible to present content (animations, media, and UI) in "slow mode" simply by varying the timing relation, assuming clients play along.</p>
<p>SYNCHRONIZATION</p>
<p>|acquire_fences| are used by Mozart to wait until all of the session's resources are ready to render (or to allow downstream components, such as the Vulkan driver, to wait for these resources).</p>
<p>For example, Fuchsia's Vulkan driver allows an zx::event to be obtained from a VkSemaphore. This allows a Mozart client to submit a Vulkan command buffer to generate images/meshes/etc., and instructing Vulkan to signal a VkSemaphore when it is done. By inserting the zx::event corresponding to this semaphore into |acquire_fences|, the client allows Mozart to submit work to the Vulkan driver without waiting on the CPU for the event to be signalled.</p>
<p>|release_fences| is a list of events that will be signalled by Mozart when the updated session state has been fully committed: future frames will be rendered using this state, and all frames generated using previous session states have been fully-rendered and presented to the display.</p>
<p>Together, |acquire_fences| and |release_fences| are intended to allow clients to implement strategies such as double-buffering. For example, a client might do the following: 1) create two <a class="el" href="struct_image.html">Image</a> with resource IDs #1 and #2. 2) create two Materials with resource IDs #3 and #4, which respectively use Images #1 and #2 as their texture. 3) create a tree of Nodes and attach them to the scene. 4) set one of the nodes above, say #5, to use <a class="el" href="struct_material.html">Material</a> #3. 5) submit a Vulkan command-buffer which renders into <a class="el" href="struct_image.html">Image</a> #1, and will signal a VkSemaphore. 6) call <a class="el" href="interface_session.html#a03362ea291f6aef33068b8371d571a2f">Present()</a> with one acquire-fence (obtained from the VkSemaphore above) and one newly-created release-fence.</p>
<p>After the steps above, Mozart will use the committed session state to render frames whenever necessary. When the client wants to display something different than <a class="el" href="struct_image.html">Image</a> #1, it would do something similar to steps 4) to 6): 7) set Node #5 to use <a class="el" href="struct_material.html">Material</a> #4. 8) submit a Vulkan command-buffer which renders into <a class="el" href="struct_image.html">Image</a> #1, and will signal a VkSemaphore. 9) call <a class="el" href="interface_session.html#a03362ea291f6aef33068b8371d571a2f">Present()</a> with one acquire-fence (obtained from the VkSemaphore above) and one newly-created release-fence.</p>
<p>Finally, to continually draw new content, the client could repeat steps 4) to 9), with one important difference: step 5) must wait on the event signalled by step 9). Otherwise, it might render into <a class="el" href="struct_image.html">Image</a> #1 while that image is still being used by Mozart to render a frame. Similarly, step 8) must wait on the event signalled by step 6).</p>
<p>The scenario described above uses one acquire-fence and one release-fence, but it is easy to imagine cases that require more. For example, in addition to using Vulkan to render into Images #1 and #2, the client might also upload other resources to Vulkan on a different VkQueue, which would would signal a separate semaphore, and therefore require an additional acquire-fence.</p>
<p>Note: |acquire_fences| and |release_fences| are only necessary to synchronize access to memory (and other external resources). Any modification to resources made via the <a class="el" href="interface_session.html">Session</a> API are automatically synchronized. </p>

</div>
</div>
<hr/>The documentation for this interface was generated from the following file:<ul>
<li>/usr/local/google/home/gregsimon/fuchsia/garnet/public/lib/ui/scenic/fidl/<a class="el" href="session_8fidl_source.html">session.fidl</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="interface_session.html">Session</a></li>
    <li class="footer">Copyright 2017 The Fuchsia Project Authors.</li>
  </ul>
</div>
</body>
</html>
